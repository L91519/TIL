# 변수의 위치를 저장하는 변수 포인터

#### 목차 

1. 개요
2. 선언과 초기화
3. 여러 종류의 포인터
   3.1. char* 의 배열
   3.2. 다중포인터
   3.3. 다차원 배열에 대한 포인터 
4. 사용되는 곳
   4.1. 포인터 메모리 할당
5. 레퍼런스

### 1. 개요

포인터 변수는 메모리의 주소를 저장하기 위한 전용 변수입니다. 이 변수를 사용하기 위해서는 포인터가 가리키는 대상의 주소를 알아야 사용할 수 있습니다. 이렇게 주소를 알고 포인터를 사용한다면 그 주소안에 들어가 있는 값을 확인하고 입력, 수정할 수 있습니다. 

____

**Q1.** *그렇다면 포인터가 가리키는 대상의 주소를 알기 위해서는 어떻게 해야할까요?*

**A1.** → *단항 연산자, 주소 연산자인  **''&''** 변수를 사용해야합니다. 이 변수가 의미하는 것은 \"이름이 ~~인 메모리의 실제 주소는?\" 입니다. 추가적인 정보로, 주소 연산과 정반대되는 개념의 연산자는 바로 간접 지정 연산자인 **"\*"** 연산자 입니다.*  

### 2. 선언과 초기화

포인터도 변수이기 때문에 기존에 사용하는 변수를 선언할 때와, 포인터 변수를 사용할 때가 크게 다르지 않습니다. 자료형도 기존에 사용하는 int, float, long, char등등입니다. 하지만 유일하게 기존의 변수와 포인터 변수가 차별화 되는 부분은 선언시 \* 연산자가 자료형과 이름 사이에 들어간다는 점입니다. 

선언방법 : **(자료형) (포인터 변수 "\*") (변수이름)**

​			ex) int 형 포인터 선언 : int* ponter

초기화 방법 : **(선언된 포인터) = (주소 연산자 "&") (포인터에 주소가 저장될 변수이름)**

​			ex)  int형 num1의 주소로 초기화 : int* pointer = &num1

___

**Q2.** 포인터 변수에 초기화된 주소에 있는 값을 불러올 때와, 주소값을 불러올 때는 어떻게 구별될까? 

**A2.** → *pointer변수에 "\*"를 붙여서 사용하면 해당 변수가 가리키는 주소에 있는 값을 나타내고 변수명만 사용하면 포인터 변수가 가리키고 있는 주소를 나타냅니다.*

```c
#include<stdio.h>

int main(void) {
    int number = 10;
    int* pointer;
    
    pointer = &number;
    
    printf("*pointer : %d \n", *pointer);
    printf("pointer : &d \n", pointer);
    
    return 0;
}
```

결과값 : 	*pointer : 10

​		pointer : 16진수로 된 변수 number의 주소

___

### 3. 여러 종류의 포인터

#### 3.1. char* 의 배열

#### 3.2. 포인터의 배열과 다중 포인터 

배열의 이름이 주소이므로, &연산자 없이 포인터 변수에 저장 할 수 있다. 

#### 3.3. 다차원 배열에 대한 포인터

### 4. 사용되는 곳

**메모리를 할당 받고 해당공간을 기억하는데 사용됩니다. **

같은 스코프가 아닌 곳에서 해당 데이터를 바꾸고 싶을 때 사용됩니다.

#### 4.1. 포인터 메모리 할당

포인터를 사용하는 가장 큰 이유가 ***메모리를 할당 받고 해당공간을 기억하는 것*** 입니다. 그렇기 때문에 포인터를 공부할 때 가장 중요한 것 역시도 메모리 할당입니다. 

포인터의 메모리 할당을 위해 가장 중요하게 사용되는 메서드 두 개를 소개하도록 하겠습니다. 

1. malloc( ) 함수

|  함수  | void *malloc(size_t size)                                    |
| :----: | ------------------------------------------------------------ |
|  인자  | size : 할당받을 메모리의 바이트 단위 크기                    |
| 반환값 | 힙 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 메모리의 주소<br />에러가 발생하면 NULL 반환 |
|  설명  | 할당받은 메모리는 반드시 free( ) 함수를 이용하여 반환해야 하며, 메모리를 초기화하려면 memset( ) 함수를 이용해야 한다. <br/>기본적으로는 쓰레기 값이 들어있다. |

2. free( ) 함수

| 함수   | void free(void * memblock)                          |
| ------ | --------------------------------------------------- |
| 인자   | memblock : 반환할 메모리의 주소                     |
| 반환값 | 없음                                                |
| 설명   | 동적으로 할당받은 메모리를 운영체제에 반환하는 함수 |

아래의 형식으로 메모리를 할당받고 반환합니다.

```c
#include<stdio.h>
#include<stdlib.h>
int main(void) 
{
    int *pointerArr = null, i = 0;
    
    pointerArr = (int*) malloc(sizeof(int) * 3);
    pointerArr[0] = 1;
    pointerArr[1] = 2;
    pointerArr[2] = 3;
    
    for(i = 0; i < 3; i ++) {
		printf("&d \n", pointerArr[i]);
    }
    
    free(pointerArr);
}
```

malloc( ) 함수는 *void가 반환형이기 때문에 (int *)를 사용하여 강제 형변환을 시켜줬습니다. C언어에서는 해주지 않아도 괜찮지만 C++언어에서는 강력하게 제제한다고 합니다.

## 5. Reference 

+ 독하게 시작하는 C 프로그래밍
+ http://prosto.tistory.com/253

