# SOLID 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다. 

+ 변경에 유연하다
+ 이해하기 쉽다
+ 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

## SRP : 단일 책임 원칙

Single Responsibility Principle, SPR은에 따르면 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

이는 함수는 단 하나의 일만 해야 한다는 의미로 받아들여지는데 해당하는 원칙은 따로 있으며 SRP란 변경이 한 명의 사람의 요청에만 따라 수행되어야한다는 것이다. 즉, 하나의 모듈은 하나의 , 오직 하나의 액터에 대해서만 책임져야한다. 단일 책임 원칙을 잘 알기 위해서는 이 원칙을 위반하는 예를 살펴보는 것이다. 

### 징후 1 : 우발적 중복

CalcuatePay( ), reportHours( ), save( ) 라는 함수를 가지고 있는 Employee라는 클래스는 단일 책임 원칙을 어긴다고 할 수 있다. 왜냐하면 이 세가지 메서드가 서로 매우 다른 액터를 책임지기 때문인데 calculatePay( )메서드는 회계팀에서 기능을 정의하면 CFO를 위해 사용되며 reportHours( )는 인사팀에서 기능을 정의하고 사용하며 COO를 위해서 사용되고 save( )는 데이터 베이스 관리자가 사용하며 CTO를 위해서 보고되기 때문이다. **이런 결합을 통해 CFO팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있게된다.** 

### 징후 2: 병합

CTO, COO에서 동시에 변셩사항을 적용하고 싶어할 때 이 때 발생하는 병합은 CTO, COO 뿐만이 아니라 CFO에게도 문제를 발생시킬 수 있다. 이러한 문제에서 벗어나기 위해서는 서로 다른 액터를 뒷받침하는 코드는 분리시키면 된다.

### 해결책

이 문제의 해결책은 다양한데, 서로 다른 액터를 바라보는 메서드는 각기 다른 클래스로 이동시키도록하면된다. 하지만 그렇게 한다면 각기 다른 인스턴스를 추적해야하기 때문에 그것에 대한 불편함이있다. 이에 대한 해결책으로는 퍼사드 패턴(Facade Patter)이 있다. 이는 퍼사드 클래스가 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 역할을 한다. 

### 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 있다. 컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이된다. 

## OCP : 개방-폐쇄 원칙

Open-Closed Principle, OCP에 따르면 소프트웨어는 기존 코드를 수정하기보다는 새로운 코드를 추가해야 한다.

이는 소프트웨어 개체의 행위는 확장할 수 있어야하지만 , 이 때 산출물을 변경해서는 안 된다는 원칙이다. 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다. OCP를 클래스 모듈을 설계할 때 도움이 되는 원칙이라고 생각 할 수 있지만 사실은 아키텍처 컴포넌트 수준을 고려할 때 훨씬 중요한 의미를 가진다. 

### 결론

OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. 이의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다. 이 목적을 당성하기 위해서는 시스템을 분리하고 의존성 계층 구조를 잘 만들어야한다. 

## LSP : 리스코프 치환 형식

Liskov Substitution Principle, LSP에 따르면 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들려면 이들의 구성요소는 서로 치환이 가능해야한다.

리스코프 치환 형식을 준수하는 하나의 예로는 License 클래스가 있고 이 클래스 안에는 calcFee라는 함수가 있을 때 Billing 어플리케이션에서 이 메서드를 호출 할 때 License의 하위 타입인 PersonlaLicense와 BuisinessLicenss 두 가지 타입 중 모두가 사용가능 하는 케이스가 있다. 반대로 리스코프 치환 형식을 위배하는 유명한 문제로는 정사각형/직사각형 문제가 있다. Resctangle이라는 클래스 안에 setH( ), setW( )라는 함수가 있을때 하위 타입으로 Square이라는 함수를 사용한다면 너비와 높이 모두 같은 값을 반환하기 때문에 혼동이 생긴다.

LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만 시간이 지나면서 LSP는 인터페이스와 구현제에도 적용되며 더 넓게는 소프트웨어 설계원칙으로 변모해 왔다. 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 무슨 일이 일어나는지를 관찰하는 것이 될 수 있다. 

이 원칙을 준수하지 않았을 때 if문으로 하나하나 체크를 하면서 동작하도록 하는 방법이 있을 수 있는데 이는 비효율적인 코드가 될 가능성이 있다. 

*아키텍처 수준까지 LSP를 확장한다는 것이 어떤 뜻일까?*

## ISP : 인터페이스 분리 원칙

Interface Segregation Principle, ISP에 따르면소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야한다. 예를 들어 다수의 사용자가 OPS라는 클래스를 사용하는데 사용자1은 OPS의 op( )만을 사용하고 사용자 2는 op2( )만을 사용한다고 가정했을때 메서드 하나가 변경되면 모든 사용자의 클래스에서 컴파일을 하고 새로 배포해야한다. 이러한 문제를 오퍼레이션을 인터페이스 단위로 부리하여 해결 할 수 있다. 

그런데 inport, use 또는 include 같은 타입의 선언문은 루비나 파이썬 등의 동적 타입 언어에서는 존재하지 않는다. 대신 런타임과 추론이 발생하는데 이러한 이유 때문에 ISP를 아키텍처가 아니라 언어와 관련된 문제라고 결론내릴 여지도 있다. 

## DIP : 의존성 역전 원칙

Dependency Inversion Principle, DIP에 따르면 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야한다.

이는 소스코드의 의존성이 추상에 의존하며 구체에는 의존하지 않아야한다는 뜻이다. 하지만 java의 String 같은 변동성의 전혀없는 구체에 대해서는 무시할 수 있다. 우리가 의존하지 않도록 피하고자하는 것은 바로 변동성이 큰 구체적인 요소들이다. 

*구체란 추상 클래스들을 구체적으로 구현한 것들을 말하는 것으로 이해했다*

### 안정된 추상화

+ 변동성이 큰 구체 클래스는 참조하지 말아라. 대신 추상 인터페이스를 참조하라.
+ 구체 함수를 오버라이드 하지 말라. 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
+ 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.